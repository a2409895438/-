# Linux

s



# 操作系统

## 1. 协程

“轻量级线程”

进程/内核态线程切换的时候需要与OS内核进行交互，保存/读取 CPU 上下文信息。内核态（Kernel）的一些数据是共享的，读写时需要同步机制，所以操作一旦陷入内核态就会消耗更多的时间

进程需要与操作系统中所有其他进程进行资源争抢，且操作系统中资源的锁是全局的；线程之间的数据一般在进程内共享，所以线程间资源共享相比如进程而言要轻一些。

协程并没有增加线程的数量，只是在线程的基础上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。

## 2. 死锁的4个条件

1. 互斥条件：一个资源每次只能被一个进程使用，即资源仅能让一个进程使用而不支持进个线程同时使用。
2. 请求与保持条件：已经拥有资源的进程在请求其他资源时并没有释放当前资源，或者进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但又对自己已获得的资源保持不放。
3. 不剥夺条件：已经获得的资源在自主释放前不能使用其他手段剥夺。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系，即各个线程对资源的需求构成了一个循环。

## 3. 虚拟内存和物理内存

物理内存（Physical Memory）是计算机硬件上实际存在的内存单元，由随机存取存储器（RAM）组成。它是计算机直接访问的内存空间，用于存储程序和数据。

虚拟内存（Virtual Memory）是在物理内存的基础上，通过操作系统的管理，为每个进程提供了一个抽象的地址空间。虚拟内存使得每个进程可以拥有独立的地址空间，从而实现了内存的隔离和保护。





# 计网

## 1. 有了 IP 地址，为什么还要用 MAC 地址？

1. 早起的以太网的实现

早期的[以太网](https://www.zhihu.com/search?q=以太网&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A28155896})只有集线器（hub），没有交换机（switch），所以发出去的包能被以太网内的所有机器监听到，因此要附带上MAC地址，每个机器只需要接受与自己MAC地址相匹配的包。

2. 整体与局部

信息传递时候，需要知道的其实是两个地址：

- 终点地址（Final destination address）
- 下一跳的地址（Next hop address）

IP地址本质上是终点地址，它在跳过路由器（hop）的时候不会改变，而MAC地址则是下一跳的地址，每跳过一次路由器都会改变。

这就是为什么还要用MAC地址的原因之一，它起到了记录下一跳的信息的作用。

注：一般来说IP地址经过路由器是不变的，不过NAT（Network address translation）例外，这也是有些人反对NAT而支持IPV6的原因之一。

3. 分层实现

如果在IP包头（header）中增加了”下一跳IP地址“这个字段，在逻辑上来说，如果IP地址够用，交换机也支持根据IP地址转发（现在的[二层交换机](https://www.zhihu.com/search?q=二层交换机&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A28155896})不支持这样做），其实MAC地址并不是必要的。

但用MAC地址和IP地址两个地址，用于分别表示物理地址和逻辑地址是有好处的。这样分层可以使网络层与链路层的协议更灵活地替换，网络层不一定非要用『IP』协议，链路层也不一定非用『以太网』协议。

这就像OSI[七层模型](https://www.zhihu.com/search?q=七层模型&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A28155896})，TCP/IP五层模型其实也不是必要的，用双层模型甚至[单层模型](https://www.zhihu.com/search?q=单层模型&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A28155896})实现网络也不是不可以的，只是那样做很蛋疼罢了。



## 2. 为什么非对称加密比对称加密慢？

因为对称加密主要的运算是**位运算**，速度非常快，如果使用硬件计算，速度会更快。以 AES 算法为例，如下图所示，其运算本质上来说就是位移和替换。

<img src="计算机基础figures/v2-6d9e8bfcd737466ab1fb5ceb94d7db68_720w.webp" alt="img" style="zoom:50%;" />

但是非对称加密计算一般都比较复杂，比如 RSA，它里面涉及到大数乘法、大数模等等运算。其加解密可以用下面的公式来表示：

<img src="计算机基础figures/v2-c8ade444d2aa0fa197da70078b2c22e5_720w.webp" alt="img" style="zoom:50%;" />

<img src="计算机基础figures/v2-dc5fa19f7194d3c8841aee1695da857e_720w.webp" alt="img" style="zoom:50%;" />

## 3. 为什么要有RPC

配合微服务解决高并发问题好处：

- 简化开发
- 提高性能
- 解耦模块
- 跨语言支持
- 提高系统可靠性